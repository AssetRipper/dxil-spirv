#version 460
#if defined(GL_AMD_gpu_shader_half_float)
#extension GL_AMD_gpu_shader_half_float : require
#elif defined(GL_EXT_shader_explicit_arithmetic_types_float16)
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#else
#error No extension available for FP16.
#endif
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require
#extension GL_KHR_cooperative_matrix : require
#extension GL_EXT_spirv_intrinsics : require
layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0, std430) restrict readonly buffer SSBO
{
    uint _m0[];
} _21;

layout(set = 0, binding = 0, std430) writeonly buffer _23_25
{
    uint _m0[];
} _25;

spirv_instruction(set = "GLSL.std.450", id = 81) float16_t spvNClamp(float16_t, float16_t, float16_t);
spirv_instruction(set = "GLSL.std.450", id = 81) f16vec2 spvNClamp(f16vec2, f16vec2, f16vec2);
spirv_instruction(set = "GLSL.std.450", id = 81) f16vec3 spvNClamp(f16vec3, f16vec3, f16vec3);
spirv_instruction(set = "GLSL.std.450", id = 81) f16vec4 spvNClamp(f16vec4, f16vec4, f16vec4);

coopmat<uint8_t, 3u, 16u, 16u, gl_MatrixUseAccumulator> CoopMatFP16toFP8(coopmat<float16_t, 3u, 16u, 16u, gl_MatrixUseAccumulator> _44)
{
    uint _52;
    _52 = 0u;
    coopmat<uint8_t, 3u, 16u, 16u, gl_MatrixUseAccumulator> coop_output;
    for (;;)
    {
        uint _53 = _52 + 1u;
        int16_t _61 = float16BitsToInt16(spvNClamp(_44[_52], float16_t(-448.0), float16_t(448.0)));
        int16_t _70 = (_61 << int16_t(1us)) - 16384s;
        int16_t _74 = (_70 >> 11s) - 1s;
        int16_t _86 = (_70 & ((_74 & (-2048s)) ^ (-1s))) | (_74 & 2048s);
        i8vec2 _93 = unpack8(_86 >> max((-_74), 0s));
        int8_t _96 = _93.y;
        coop_output[_52] = ((uint8_t(_96) + ((uint8_t((_96 & int8_t(1)) | (_93.x | int8_t(_86 & 127s))) > uint8_t(128)) ? uint8_t(1) : uint8_t(0))) & uint8_t(127)) | (unpack8(_61).y & uint8_t(128));
        if (_53 < uint(coopmat<uint8_t, 3u, 16u, 16u, gl_MatrixUseAccumulator>(0).length()))
        {
            _52 = _53;
        }
        else
        {
            break;
        }
    }
    return coop_output;
}

void main()
{
    coopmat<float16_t, 3u, 16u, 16u, gl_MatrixUseA> _30;
    coopMatLoad(_30, _21._m0, 0u, 8u, 0u);
    coopmat<float16_t, 3u, 16u, 16u, gl_MatrixUseB> _33;
    coopMatLoad(_33, _21._m0, 128u, 8u, 1u);
    coopmat<float, 3u, 16u, 16u, gl_MatrixUseAccumulator> _36;
    coopMatLoad(_36, _21._m0, 256u, 16u, 1u);
    coopmat<float16_t, 3u, 16u, 16u, gl_MatrixUseAccumulator> _113 = coopmat<float16_t, 3u, 16u, 16u, gl_MatrixUseAccumulator>(coopMatMulAdd(_30, _33, _36, 0));
    coopMatStore(CoopMatFP16toFP8(_113), _25._m0, 0u, 4u, 1u);
}


#if 0
// SPIR-V disassembly
// WaveSize(32)
; SPIR-V
; Version: 1.3
; Generator: Unknown(30017); 21022
; Bound: 119
; Schema: 0
OpCapability Shader
OpCapability Float16
OpCapability Int16
OpCapability Int8
OpCapability DenormPreserve
OpCapability CooperativeMatrixKHR
OpExtension "SPV_KHR_cooperative_matrix"
OpExtension "SPV_KHR_float_controls"
%57 = OpExtInstImport "GLSL.std.450"
OpMemoryModel Logical GLSL450
OpEntryPoint GLCompute %3 "main"
OpExecutionMode %3 LocalSize 32 1 1
OpExecutionMode %3 DenormPreserve 16
OpName %3 "main"
OpName %19 "SSBO"
OpName %23 "SSBO"
OpName %45 "CoopMatFP16toFP8"
OpName %48 "coop_output"
OpDecorate %18 ArrayStride 4
OpMemberDecorate %19 0 Offset 0
OpDecorate %19 Block
OpDecorate %21 DescriptorSet 0
OpDecorate %21 Binding 0
OpDecorate %21 NonWritable
OpDecorate %21 Restrict
OpDecorate %22 ArrayStride 4
OpMemberDecorate %23 0 Offset 0
OpDecorate %23 Block
OpDecorate %25 DescriptorSet 0
OpDecorate %25 Binding 0
OpDecorate %25 NonReadable
%1 = OpTypeVoid
%2 = OpTypeFunction %1
%5 = OpTypeFloat 16
%6 = OpTypeInt 32 0
%7 = OpConstant %6 0
%8 = OpConstant %6 16
%10 = OpConstant %6 3
%9 = OpTypeCooperativeMatrixKHR %5 %10 %8 %8 %7
%11 = OpConstant %6 1
%12 = OpTypeCooperativeMatrixKHR %5 %10 %8 %8 %11
%13 = OpTypeFloat 32
%14 = OpConstant %6 2
%15 = OpTypeCooperativeMatrixKHR %13 %10 %8 %8 %14
%16 = OpTypeInt 8 0
%17 = OpTypeCooperativeMatrixKHR %16 %10 %8 %8 %14
%18 = OpTypeRuntimeArray %6
%19 = OpTypeStruct %18
%20 = OpTypePointer StorageBuffer %19
%21 = OpVariable %20 StorageBuffer
%22 = OpTypeRuntimeArray %6
%23 = OpTypeStruct %22
%24 = OpTypePointer StorageBuffer %23
%25 = OpVariable %24 StorageBuffer
%27 = OpConstant %6 8
%28 = OpTypePointer StorageBuffer %6
%31 = OpConstant %6 128
%34 = OpConstant %6 256
%38 = OpTypeCooperativeMatrixKHR %5 %10 %8 %8 %14
%40 = OpTypeBool
%41 = OpTypeInt 16 1
%42 = OpTypePointer Function %38
%43 = OpTypeFunction %17 %42
%47 = OpTypePointer Function %17
%54 = OpTypePointer Function %5
%59 = OpConstant %5 -0x1.cp+8
%60 = OpConstant %5 0x1.cp+8
%62 = OpTypeVector %16 2
%66 = OpConstant %16 128
%68 = OpTypeInt 16 0
%69 = OpConstant %68 1
%71 = OpConstant %41 16384
%73 = OpConstant %41 11
%75 = OpConstant %41 1
%78 = OpConstant %41 0
%80 = OpConstant %41 2048
%82 = OpConstant %41 -2048
%84 = OpConstant %41 -1
%88 = OpConstant %41 127
%89 = OpTypeInt 8 1
%92 = OpTypeVector %89 2
%98 = OpConstant %89 1
%102 = OpConstant %16 1
%103 = OpConstant %16 0
%106 = OpConstant %16 127
%108 = OpTypePointer Function %16
%115 = OpConstant %6 4
%3 = OpFunction %1 None %2
%4 = OpLabel
%113 = OpVariable %42 Function
OpBranch %117
%117 = OpLabel
%29 = OpAccessChain %28 %21 %7 %7
%30 = OpCooperativeMatrixLoadKHR %9 %29 %7 %27
%32 = OpAccessChain %28 %21 %7 %31
%33 = OpCooperativeMatrixLoadKHR %12 %32 %11 %27
%35 = OpAccessChain %28 %21 %7 %34
%36 = OpCooperativeMatrixLoadKHR %15 %35 %11 %8
%37 = OpCooperativeMatrixMulAddKHR %15 %30 %33 %36
%39 = OpFConvert %38 %37
OpStore %113 %39
%114 = OpFunctionCall %17 %45 %113
%116 = OpAccessChain %28 %25 %7 %7
OpCooperativeMatrixStoreKHR %116 %114 %11 %115
OpReturn
OpFunctionEnd
%45 = OpFunction %17 None %43
%44 = OpFunctionParameter %42
%46 = OpLabel
%48 = OpVariable %47 Function
%49 = OpCooperativeMatrixLengthKHR %6 %17
OpBranch %50
%50 = OpLabel
%52 = OpPhi %6 %7 %46 %53 %50
%53 = OpIAdd %6 %52 %11
%55 = OpInBoundsAccessChain %54 %44 %52
%56 = OpLoad %5 %55
%58 = OpExtInst %5 %57 NClamp %56 %59 %60
%61 = OpBitcast %41 %58
%63 = OpBitcast %62 %61
%64 = OpCompositeExtract %16 %63 1
%65 = OpBitwiseAnd %16 %64 %66
%67 = OpShiftLeftLogical %41 %61 %69
%70 = OpISub %41 %67 %71
%72 = OpShiftRightArithmetic %41 %70 %73
%74 = OpISub %41 %72 %75
%76 = OpSNegate %41 %74
%77 = OpExtInst %41 %57 SMax %76 %78
%79 = OpBitwiseAnd %41 %74 %80
%81 = OpBitwiseAnd %41 %74 %82
%83 = OpBitwiseXor %41 %81 %84
%85 = OpBitwiseAnd %41 %70 %83
%86 = OpBitwiseOr %41 %85 %79
%87 = OpBitwiseAnd %41 %86 %88
%90 = OpSConvert %89 %87
%91 = OpShiftRightArithmetic %41 %86 %77
%93 = OpBitcast %92 %91
%94 = OpCompositeExtract %89 %93 0
%95 = OpBitwiseOr %89 %94 %90
%96 = OpCompositeExtract %89 %93 1
%97 = OpBitwiseAnd %89 %96 %98
%99 = OpBitwiseOr %89 %97 %95
%100 = OpUGreaterThan %40 %99 %66
%101 = OpSelect %16 %100 %102 %103
%104 = OpIAdd %16 %96 %101
%105 = OpBitwiseAnd %16 %104 %106
%107 = OpBitwiseOr %16 %105 %65
%109 = OpInBoundsAccessChain %108 %48 %52
OpStore %109 %107
%110 = OpULessThan %40 %53 %49
OpLoopMerge %51 %50 None
OpBranchConditional %110 %50 %51
%51 = OpLabel
%111 = OpLoad %17 %48
OpReturnValue %111
OpFunctionEnd
#endif
